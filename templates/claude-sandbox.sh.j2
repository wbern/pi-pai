#!/bin/bash
set -e

# Project session: isolated to specific project directory
run_project() {
    local prompt="$1"
    local workdir="${2:-/workspace}"
    local window_name="$3"

    # --resume sentinel: pass --continue to Claude Code to resume last conversation
    local claude_args=""
    if [[ "$prompt" == "--resume" ]]; then
        claude_args="--continue"
    elif [[ -n "$prompt" ]]; then
        claude_args="$prompt"
    fi

    docker run -it --rm \
        --init \
        --shm-size={{ docker_shm_size }} \
        --memory {{ docker_memory_limit }} \
        --add-host=host.docker.internal:host-gateway \
        -v ~/Sessions${workdir}:${workdir} \
        -v ~/.claude-docker:/home/node/.claude \
        -v ~/.claude-docker/.ssh:/home/node/.ssh:ro \
        -v ~/.claude-docker/.happy:/home/node/.happy \
        -w "$workdir" \
        -e TERM=xterm-256color \
        -e COLORTERM=truecolor \
        -e TMPDIR=/home/node/.claude/tmp \
        -e CLAUDE_CODE_DISABLE_NONESSENTIAL_TRAFFIC=1 \
        -e GITHUB_PAT="$(cat ~/.claude-docker/.github_token 2>/dev/null)" \
        -e CONTEXT7_TOKEN="$(cat ~/.claude-docker/.context7_token 2>/dev/null)" \
        -e CLAUDE_CODE_OAUTH_TOKEN="$(cat ~/.claude-docker/.oauth_token 2>/dev/null)" \
        -e CLAUDE_CONFIG_DIR="/home/node/.claude" \
        ${window_name:+-e TMUX_WINDOW_NAME="$window_name"} \
        claude-code ${claude_args:+"$claude_args"}
}

# --run "prompt" "workdir" "window_name": internal, called by tmux to run project session
if [[ "$1" == "--run" ]]; then
    run_project "$2" "$3" "$4"
    exit 0
fi

# No args: run control plane (isolated - no repo access, no SSH)
#
# Recovery: retries on crash with backoff (primary), systemd Restart=always (fallback).
# The systemd fallback only triggers if this script exits AND no spawned tmux windows
# remain — otherwise the tmux session stays alive and systemd sees "active".
if [[ -z "$1" ]]; then
    log_cp() { echo "$1" >&2; logger -t claude-control-plane "$1" 2>/dev/null || true; }

    FAILURES=0
    MAX_FAILURES={{ control_plane_max_restarts | default(5) }}

    # tmux PTY needs a moment to initialize after new-session -d
    sleep 2

    while true; do
        # || captures non-zero exit without triggering set -e
        EXIT_CODE=0
        START_TIME=$(date +%s)
        docker run -it --rm \
            --init \
            --shm-size={{ docker_shm_size }} \
            --memory {{ docker_memory_limit }} \
            --add-host=host.docker.internal:host-gateway \
            -v ~/.claude-control-plane/workspace:/control-plane \
            -v ~/.claude-docker:/home/node/.claude \
            -v ~/.claude-docker/.happy:/home/node/.happy \
            -w /control-plane \
            -e TERM=xterm-256color \
            -e COLORTERM=truecolor \
            -e TMPDIR=/home/node/.claude/tmp \
            -e CLAUDE_CODE_DISABLE_NONESSENTIAL_TRAFFIC=1 \
            -e GITHUB_PAT="$(cat ~/.claude-docker/.github_token 2>/dev/null)" \
            -e CONTEXT7_TOKEN="$(cat ~/.claude-docker/.context7_token 2>/dev/null)" \
            -e CLAUDE_CODE_OAUTH_TOKEN="$(cat ~/.claude-docker/.oauth_token 2>/dev/null)" \
            -e CLAUDE_CONFIG_DIR="/home/node/.claude" \
            claude-code || EXIT_CODE=$?

        # Clean exit (0), SIGINT (130/Ctrl-C), or SIGTERM (143) — don't restart
        if [[ $EXIT_CODE -eq 0 || $EXIT_CODE -eq 130 || $EXIT_CODE -eq 143 ]]; then
            log_cp "Control plane exited (code $EXIT_CODE)."
            break
        fi

        # Reset failure counter if the container ran for >60s (not a crash loop)
        DURATION=$(( $(date +%s) - START_TIME ))
        if [[ $DURATION -gt 60 ]]; then
            FAILURES=0
        fi

        FAILURES=$((FAILURES + 1))
        if [[ $FAILURES -ge $MAX_FAILURES ]]; then
            log_cp "Control plane failed $FAILURES times in quick succession, giving up."
            break
        fi

        DELAY=$((5 * FAILURES))
        log_cp "Control plane exited ($EXIT_CODE after ${DURATION}s), restarting in ${DELAY}s... ($FAILURES/$MAX_FAILURES)"
        sleep "$DELAY"
    done
    exit 0
fi

# --spawn "workdir" "prompt" "window_name": MCP entry point for spawning sessions
#
# Prompt Escaping Limitations:
#   - Max length: 500 chars (truncated by server.js)
#   - Single quotes: escaped via '\'' substitution
#   - Works: alphanumeric, spaces, basic punctuation (.,-:;!?)
#   - May break: newlines, backticks, backslashes, $variables
#   - Safe: prompts are natural language instructions, not code
#
# The MCP server (server.js) sanitizes repo/window_name inputs via allowlist.
# Instructions are NOT sanitized (may contain punctuation) but are passed via
# array args to spawn() with shell:false, preventing injection.
if [[ "$1" == "--spawn" ]]; then
    SESSION_DIR="${2:?SESSION_DIR required}"
    PROMPT="$3"
    WINDOW_NAME="${4:-session-$(date +%s)}"

    # Create session directory on host (SESSION_DIR is like /repo--session-name--hash)
    HOST_DIR="${HOME}/Sessions${SESSION_DIR}"
    if [[ ! -d "$HOST_DIR" ]]; then
        mkdir -p "$HOST_DIR"
    fi

    ESCAPED="${PROMPT//\'/\'\\\'\'}"
    tmux new-window -t {{ tmux_session_name }}: -n "$WINDOW_NAME" \
        "$HOME/claude-sandbox.sh --run '$ESCAPED' '$SESSION_DIR' '$WINDOW_NAME'"
    echo "Spawned window '$WINDOW_NAME' at '$SESSION_DIR'"
    exit 0
fi

echo "Usage:"
echo "  $0                                        Run control plane (isolated)"
echo "  $0 --spawn 'dir' 'prompt' 'name'          Spawn project session via MCP"
echo "  $0 --run 'prompt' 'workdir' 'window_name' Internal: run project session"
exit 1
