import express from "express";
import { execFileSync, spawn } from "child_process";
import { sanitize, buildPrompt, generateWindowName, generateSessionDir } from "./lib.js";

const app = express();
const PORT = {{ mcp_server_port }};
const BEARER_TOKEN = "{{ mcp_bearer_token }}";

app.use(express.json());

// Safe shell execution using execFileSync (no shell interpolation)
function run(cmd, args = []) {
  try {
    return execFileSync(cmd, args, { encoding: "utf8", timeout: 30000 }).trim();
  } catch (e) {
    throw new Error(e.stderr || e.message);
  }
}

const TOOLS = [
  {
    name: "list_sessions",
    description: "List all active tmux windows in the Claude session",
    inputSchema: { type: "object", properties: {}, required: [] }
  },
  {
    name: "spawn_session",
    description: "Spawn a new Claude project session. Can clone repos, run tasks, or start blank sessions.",
    inputSchema: {
      type: "object",
      properties: {
        repo: { type: "string", description: "Git URL to clone (e.g., github.com/user/repo)" },
        instruction: { type: "string", description: "Task or instructions for Claude" },
        session_name: { type: "string", description: "Session name (slugified, max 30 chars, used for volume mount)" },
        window_name: { type: "string", description: "Custom window name (auto-generated if not provided)" }
      },
      required: []
    }
  },
  {
    name: "kill_session",
    description: "Kill a tmux window by name or index",
    inputSchema: {
      type: "object",
      properties: {
        target: { type: "string", description: "Window name or index to kill" }
      },
      required: ["target"]
    }
  },
  {
    name: "end_session",
    description: "End a Claude session by window name. Use list_sessions first to find window names.",
    inputSchema: {
      type: "object",
      properties: {
        window: { type: "string", description: "Window name from list_sessions" }
      },
      required: ["window"]
    }
  },
  {
    name: "restart_self",
    description: "Restart current session to pick up CLAUDE.md and settings. Call after cloning a repo.",
    inputSchema: {
      type: "object",
      properties: {
        window_name: { type: "string", description: "Current window name (from TMUX_WINDOW_NAME env var)" },
        instruction: { type: "string", description: "Task to continue after restart" }
      },
      required: ["window_name"]
    }
  }
];

const toolHandlers = {
  list_sessions: async () => {
    try {
      const output = run("tmux", ["list-windows", "-t", "{{ tmux_session_name }}", "-F", "#{window_index}: #{window_name}"]);
      return { content: [{ type: "text", text: output || "No windows found" }] };
    } catch (e) {
      return { content: [{ type: "text", text: `Error: ${e.message}` }], isError: true };
    }
  },

  spawn_session: async ({ repo, instruction, session_name, window_name }) => {
    // Sanitize inputs to prevent injection
    const safeRepo = sanitize(repo, true);  // allow slashes for URLs
    const safeSessionName = sanitize(session_name);
    const truncatedInstruction = instruction ? instruction.substring(0, 500) : "";

    // Generate session directory, prompt, and window name using pure functions
    const sessionDir = generateSessionDir(safeRepo, safeSessionName);
    const prompt = buildPrompt(safeRepo, truncatedInstruction);
    const windowName = generateWindowName(safeRepo, sanitize(window_name), safeSessionName);

    try {
      // Use spawn with array arguments (no shell interpolation)
      // Args: --spawn <workdir> <prompt> <window_name>
      const result = await new Promise((resolve, reject) => {
        const child = spawn(
          `${process.env.HOME}/claude-sandbox.sh`,
          ["--spawn", sessionDir, prompt, windowName],
          { timeout: 600000, shell: false }
        );
        let stdout = "", stderr = "";
        child.stdout.on("data", d => stdout += d);
        child.stderr.on("data", d => stderr += d);
        child.on("close", code => {
          if (code !== 0) reject(new Error(stderr || `Exit code ${code}`));
          else resolve(stdout);
        });
        child.on("error", reject);
      });
      console.log("Spawned:", result);
      return { content: [{ type: "text", text: `Spawned "${windowName}" at ${sessionDir}. Use list_sessions to see all windows.` }] };
    } catch (e) {
      console.error("Spawn error:", e.message);
      return { content: [{ type: "text", text: `Failed to spawn "${windowName}": ${e.message}` }], isError: true };
    }
  },

  kill_session: async ({ target }) => {
    const safeTarget = sanitize(target);
    if (!safeTarget) {
      return { content: [{ type: "text", text: "Error: Invalid target" }], isError: true };
    }
    try {
      run("tmux", ["kill-window", "-t", `{{ tmux_session_name }}:${safeTarget}`]);
      return { content: [{ type: "text", text: `Killed window: ${safeTarget}` }] };
    } catch (e) {
      return { content: [{ type: "text", text: `Error: ${e.message}` }], isError: true };
    }
  },

  // Alias for kill_session (same functionality, different API)
  end_session: async ({ window }) => {
    return toolHandlers.kill_session({ target: window });
  },

  restart_self: async ({ window_name, instruction }) => {
    const safeName = sanitize(window_name);
    const truncatedInstruction = instruction ? instruction.substring(0, 500) : "";

    if (!safeName) {
      return { content: [{ type: "text", text: "Error: window_name is required" }], isError: true };
    }

    try {
      // Get current window's working directory from tmux
      const sessionDir = run("tmux", [
        "display-message",
        "-t", `{{ tmux_session_name }}:${safeName}`,
        "-p", "#{pane_current_path}"
      ]);

      // Atomic restart using tmux's direct execution mode (multiple args = no shell)
      // respawn-window -k preserves window name/index with no race conditions
      run("tmux", [
        "respawn-window", "-k",
        "-t", `{{ tmux_session_name }}:${safeName}`,
        `${process.env.HOME}/claude-sandbox.sh`, "--run", truncatedInstruction, sessionDir, safeName
      ]);

      console.log("Restarted:", safeName, "at", sessionDir);
      return { content: [{ type: "text", text: `Restarted session '${safeName}' at ${sessionDir}` }] };
    } catch (e) {
      console.error("Restart error:", e.message);
      return { content: [{ type: "text", text: `Failed to restart '${safeName}': ${e.message}` }], isError: true };
    }
  }
};

function validateAuth(req, res, next) {
  const auth = req.headers.authorization;
  if (!auth || auth !== `Bearer ${BEARER_TOKEN}`) {
    return res.status(401).json({ error: "Unauthorized" });
  }
  next();
}

async function handleJsonRpc(request) {
  const { method, params, id } = request;

  switch (method) {
    case "initialize":
      return {
        jsonrpc: "2.0", id,
        result: {
          protocolVersion: "2024-11-05",
          capabilities: { tools: {} },
          serverInfo: { name: "tmux-control-plane", version: "1.0.0" }
        }
      };
    case "notifications/initialized":
      return null;
    case "tools/list":
      return { jsonrpc: "2.0", id, result: { tools: TOOLS } };
    case "tools/call":
      const { name, arguments: args } = params;
      const handler = toolHandlers[name];
      if (!handler) {
        return { jsonrpc: "2.0", id, error: { code: -32601, message: `Unknown tool: ${name}` } };
      }
      const result = await handler(args || {});
      return { jsonrpc: "2.0", id, result };
    default:
      return { jsonrpc: "2.0", id, error: { code: -32601, message: `Method not found: ${method}` } };
  }
}

app.post("/mcp", validateAuth, async (req, res) => {
  try {
    const response = await handleJsonRpc(req.body);
    if (response === null) return res.status(202).end();
    res.json(response);
  } catch (e) {
    res.status(500).json({ jsonrpc: "2.0", id: req.body?.id, error: { code: -32603, message: e.message } });
  }
});

app.get("/health", (req, res) => res.json({ status: "ok" }));

app.listen(PORT, "0.0.0.0", () => {
  console.log(`tmux-control-plane running on http://0.0.0.0:${PORT}/mcp`);
});
