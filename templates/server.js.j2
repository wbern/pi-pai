import express from "express";
import { execFileSync, spawn } from "child_process";
import { readFileSync, existsSync } from "fs";
import { join } from "path";
import { sanitize, buildPrompt, generateWindowName, generateSessionDir, parseMemAvailable, parseContainerCount } from "./lib.js";
import { addSession, removeSession, getAllSessions, reconcile } from "./registry.js";

const app = express();
const PORT = {{ mcp_server_port }};
const BEARER_TOKEN = "{{ mcp_bearer_token }}";
const SESSION_TOKEN = "{{ mcp_session_token }}";
const SESSION_TOOLS = new Set(["restart_self", "restart_service", "check_resources"]);
const MAX_SESSIONS = {{ max_project_sessions | default(2) }};
const MIN_MEMORY_MB = {{ min_available_memory_mb | default(512) }};
const RESTORE_DELAY = {{ session_restore_delay | default(15) }};
const REGISTRY_PATH = join(process.env.HOME, ".claude-docker", "sessions.json");

app.use(express.json());

// Safe shell execution using execFileSync (no shell interpolation)
function run(cmd, args = []) {
  try {
    return execFileSync(cmd, args, { encoding: "utf8", timeout: 30000 }).trim();
  } catch (e) {
    throw new Error(e.stderr || e.message);
  }
}

// Get list of active tmux window names
function getTmuxWindows() {
  try {
    const output = run("tmux", ["list-windows", "-t", "{{ tmux_session_name }}", "-F", "#{window_name}"]);
    return output.split("\n").filter(n => n.trim() !== "");
  } catch {
    return [];
  }
}

// Check if the Pi has enough resources to spawn a new session
function checkResources() {
  // Memory check
  try {
    const meminfo = readFileSync("/proc/meminfo", "utf8");
    const availMb = parseMemAvailable(meminfo);
    if (availMb >= 0 && availMb < MIN_MEMORY_MB) {
      return { ok: false, reason: `Insufficient memory: ${availMb}MB available, ${MIN_MEMORY_MB}MB required` };
    }
  } catch {
    // /proc/meminfo not available (e.g. macOS) — skip check
  }

  // Container count check (subtract 1 for the always-running control plane container)
  try {
    const psOutput = run("docker", ["ps", "--filter", `ancestor={{ docker_image_name }}`, "--format", "{% raw %}{{.Names}}{% endraw %}"]);
    const total = parseContainerCount(psOutput);
    const projectCount = Math.max(0, total - 1);
    if (projectCount >= MAX_SESSIONS) {
      return { ok: false, reason: `Too many sessions: ${projectCount} running, max ${MAX_SESSIONS}` };
    }
  } catch {
    // docker ps failed — skip check
  }

  return { ok: true };
}

const TOOLS = [
  {
    name: "list_sessions",
    description: "List all active tmux windows in the Claude session",
    inputSchema: { type: "object", properties: {}, required: [] }
  },
  {
    name: "spawn_session",
    description: "Spawn a new Claude project session. Can clone repos, run tasks, or start blank sessions.",
    inputSchema: {
      type: "object",
      properties: {
        repo: { type: "string", description: "Git URL to clone (e.g., github.com/user/repo)" },
        instruction: { type: "string", description: "Task or instructions for Claude" },
        session_name: { type: "string", description: "Session name (slugified, max 30 chars, used for volume mount)" },
        window_name: { type: "string", description: "Custom window name (auto-generated if not provided)" }
      },
      required: []
    }
  },
  {
    name: "kill_session",
    description: "Kill a tmux window by name or index",
    inputSchema: {
      type: "object",
      properties: {
        target: { type: "string", description: "Window name or index to kill" }
      },
      required: ["target"]
    }
  },
  {
    name: "end_session",
    description: "End a Claude session by window name. Use list_sessions first to find window names.",
    inputSchema: {
      type: "object",
      properties: {
        window: { type: "string", description: "Window name from list_sessions" }
      },
      required: ["window"]
    }
  },
  {
    name: "restart_self",
    description: "Restart current session to pick up CLAUDE.md and settings. Call after cloning a repo.",
    inputSchema: {
      type: "object",
      properties: {
        window_name: { type: "string", description: "Current window name (from TMUX_WINDOW_NAME env var)" },
        instruction: { type: "string", description: "Task to continue after restart" }
      },
      required: ["window_name"]
    }
  },
  {
    name: "restart_service",
    description: "Restart a systemd user service by name. Use when a service (e.g. github-mcp) is unresponsive.",
    inputSchema: {
      type: "object",
      properties: {
        service: { type: "string", description: "Service name to restart (e.g. 'github-mcp')" }
      },
      required: ["service"]
    }
  },
  {
    name: "check_resources",
    description: "Check if the Pi has enough resources (memory, container slots) to spawn a new session.",
    inputSchema: { type: "object", properties: {}, required: [] }
  },
  {
    name: "restore_sessions",
    description: "Restore previously registered sessions after reboot. Skips already-running sessions.",
    inputSchema: { type: "object", properties: {}, required: [] }
  },
  {
    name: "read_session",
    description: "Read the current screen content of a tmux session window. Returns the last N lines visible in the pane.",
    inputSchema: {
      type: "object",
      properties: {
        target: { type: "string", description: "Window name (from list_sessions)" },
        lines: { type: "number", description: "Number of lines of scrollback to capture (default 50, max 500)" }
      },
      required: ["target"]
    }
  },
  {
    name: "send_to_session",
    description: "Send a message or keystrokes to a tmux session window. The text is typed into the active pane followed by Enter.",
    inputSchema: {
      type: "object",
      properties: {
        target: { type: "string", description: "Window name (from list_sessions)" },
        text: { type: "string", description: "Text to send (followed by Enter)" },
        enter: { type: "boolean", description: "Whether to press Enter after the text (default true)" }
      },
      required: ["target", "text"]
    }
  }
];

const toolHandlers = {
  list_sessions: async () => {
    try {
      const output = run("tmux", ["list-windows", "-t", "{{ tmux_session_name }}", "-F", "#{window_index}: #{window_name}"]);
      // Reconcile registry with live windows
      const liveWindows = getTmuxWindows();
      const pruned = reconcile(REGISTRY_PATH, liveWindows);
      if (pruned.length > 0) {
        console.log("Pruned stale registry entries:", pruned);
      }
      return { content: [{ type: "text", text: output || "No windows found" }] };
    } catch (e) {
      return { content: [{ type: "text", text: `Error: ${e.message}` }], isError: true };
    }
  },

  spawn_session: async ({ repo, instruction, session_name, window_name }) => {
    // Resource check before spawning
    const resources = checkResources();
    if (!resources.ok) {
      return { content: [{ type: "text", text: `Cannot spawn: ${resources.reason}` }], isError: true };
    }

    // Sanitize inputs to prevent injection
    const safeRepo = sanitize(repo, true);  // allow slashes for URLs
    const safeSessionName = sanitize(session_name);
    const truncatedInstruction = instruction ? instruction.substring(0, 500) : "";

    // Generate session directory, prompt, and window name using pure functions
    const sessionDir = generateSessionDir(safeRepo, safeSessionName);
    const prompt = buildPrompt(safeRepo, truncatedInstruction);
    const windowName = generateWindowName(safeRepo, sanitize(window_name), safeSessionName);

    try {
      // Use spawn with array arguments (no shell interpolation)
      // Args: --spawn <workdir> <prompt> <window_name>
      const result = await new Promise((resolve, reject) => {
        const child = spawn(
          `${process.env.HOME}/claude-sandbox.sh`,
          ["--spawn", sessionDir, prompt, windowName],
          { timeout: 600000, shell: false }
        );
        let stdout = "", stderr = "";
        child.stdout.on("data", d => stdout += d);
        child.stderr.on("data", d => stderr += d);
        child.on("close", code => {
          if (code !== 0) reject(new Error(stderr || `Exit code ${code}`));
          else resolve(stdout);
        });
        child.on("error", reject);
      });
      console.log("Spawned:", result);

      // Register session for restore-on-reboot
      addSession(REGISTRY_PATH, windowName, sessionDir, safeRepo);

      return { content: [{ type: "text", text: `Spawned "${windowName}" at ${sessionDir}. Use list_sessions to see all windows.` }] };
    } catch (e) {
      console.error("Spawn error:", e.message);
      return { content: [{ type: "text", text: `Failed to spawn "${windowName}": ${e.message}` }], isError: true };
    }
  },

  kill_session: async ({ target }) => {
    const safeTarget = sanitize(target);
    if (!safeTarget) {
      return { content: [{ type: "text", text: "Error: Invalid target" }], isError: true };
    }
    try {
      run("tmux", ["kill-window", "-t", `{{ tmux_session_name }}:${safeTarget}`]);
      // Remove from registry
      removeSession(REGISTRY_PATH, safeTarget);
      return { content: [{ type: "text", text: `Killed window: ${safeTarget}` }] };
    } catch (e) {
      return { content: [{ type: "text", text: `Error: ${e.message}` }], isError: true };
    }
  },

  // Alias for kill_session (same functionality, different API)
  end_session: async ({ window }) => {
    return toolHandlers.kill_session({ target: window });
  },

  restart_service: async ({ service }) => {
    const ALLOWED_SERVICES = ["github-mcp"];
    if (!ALLOWED_SERVICES.includes(service)) {
      return { content: [{ type: "text", text: `Error: service '${service}' not in allowlist [${ALLOWED_SERVICES.join(", ")}]` }], isError: true };
    }
    try {
      run("systemctl", ["--user", "restart", service]);
      console.log("Restarted service:", service);
      return { content: [{ type: "text", text: `Restarted ${service}` }] };
    } catch (e) {
      return { content: [{ type: "text", text: `Failed to restart ${service}: ${e.message}` }], isError: true };
    }
  },

  restart_self: async ({ window_name, instruction }) => {
    const safeName = sanitize(window_name);
    const truncatedInstruction = instruction ? instruction.substring(0, 500) : "";

    if (!safeName) {
      return { content: [{ type: "text", text: "Error: window_name is required" }], isError: true };
    }

    try {
      // Get current window's working directory from tmux
      const sessionDir = run("tmux", [
        "display-message",
        "-t", `{{ tmux_session_name }}:${safeName}`,
        "-p", "#{pane_current_path}"
      ]);

      // Atomic restart using tmux's direct execution mode (multiple args = no shell)
      // respawn-window -k preserves window name/index with no race conditions
      run("tmux", [
        "respawn-window", "-k",
        "-t", `{{ tmux_session_name }}:${safeName}`,
        `${process.env.HOME}/claude-sandbox.sh`, "--run", truncatedInstruction, sessionDir, safeName
      ]);

      console.log("Restarted:", safeName, "at", sessionDir);
      return { content: [{ type: "text", text: `Restarted session '${safeName}' at ${sessionDir}` }] };
    } catch (e) {
      console.error("Restart error:", e.message);
      return { content: [{ type: "text", text: `Failed to restart '${safeName}': ${e.message}` }], isError: true };
    }
  },

  check_resources: async () => {
    const resources = checkResources();
    // Also include raw info for the caller
    let info = `Status: ${resources.ok ? "OK" : "BLOCKED"}`;
    if (!resources.ok) info += `\nReason: ${resources.reason}`;

    try {
      const meminfo = readFileSync("/proc/meminfo", "utf8");
      const availMb = parseMemAvailable(meminfo);
      if (availMb >= 0) info += `\nMemory available: ${availMb}MB (min: ${MIN_MEMORY_MB}MB)`;
    } catch { /* skip */ }

    try {
      const psOutput = run("docker", ["ps", "--filter", `ancestor={{ docker_image_name }}`, "--format", "{% raw %}{{.Names}}{% endraw %}"]);
      const total = parseContainerCount(psOutput);
      const projectCount = Math.max(0, total - 1);
      info += `\nProject sessions: ${projectCount}/${MAX_SESSIONS}`;
    } catch { /* skip */ }

    return { content: [{ type: "text", text: info }] };
  },

  read_session: async ({ target, lines }) => {
    const safeTarget = sanitize(target);
    if (!safeTarget) {
      return { content: [{ type: "text", text: "Error: Invalid target" }], isError: true };
    }
    const lineCount = Math.min(Math.max(lines || 50, 1), 500);
    try {
      const output = run("tmux", [
        "capture-pane", "-t", `{{ tmux_session_name }}:${safeTarget}`,
        "-p", "-S", `-${lineCount}`
      ]);
      return { content: [{ type: "text", text: output || "(empty)" }] };
    } catch (e) {
      return { content: [{ type: "text", text: `Error: ${e.message}` }], isError: true };
    }
  },

  send_to_session: async ({ target, text, enter }) => {
    const safeTarget = sanitize(target);
    if (!safeTarget) {
      return { content: [{ type: "text", text: "Error: Invalid target" }], isError: true };
    }
    if (!text) {
      return { content: [{ type: "text", text: "Error: text is required" }], isError: true };
    }
    try {
      const args = ["send-keys", "-t", `{{ tmux_session_name }}:${safeTarget}`, text];
      if (enter !== false) {
        args.push("Enter");
      }
      run("tmux", args);
      return { content: [{ type: "text", text: `Sent to ${safeTarget}` }] };
    } catch (e) {
      return { content: [{ type: "text", text: `Error: ${e.message}` }], isError: true };
    }
  },

  restore_sessions: async () => {
    const sessions = getAllSessions(REGISTRY_PATH);
    const entries = Object.entries(sessions);
    if (entries.length === 0) {
      return { content: [{ type: "text", text: "No sessions to restore" }] };
    }

    const liveWindows = new Set(getTmuxWindows());
    const results = [];
    let spawned = 0;

    for (const [windowName, session] of entries) {
      // Skip already-running sessions
      if (liveWindows.has(windowName)) {
        results.push(`${windowName}: already running`);
        continue;
      }

      // Verify session directory exists on disk
      const hostDir = join(process.env.HOME, "Sessions", session.dir);
      if (!existsSync(hostDir)) {
        removeSession(REGISTRY_PATH, windowName);
        results.push(`${windowName}: removed (directory missing)`);
        continue;
      }

      // Check resources before each spawn
      const resources = checkResources();
      if (!resources.ok) {
        results.push(`${windowName}: skipped (${resources.reason})`);
        break; // Stop restoring if resources exhausted
      }

      // Stagger spawns to avoid overwhelming RAM
      if (spawned > 0) {
        await new Promise(r => setTimeout(r, 10000));
      }

      // Spawn with --resume to continue last conversation
      try {
        await new Promise((resolve, reject) => {
          const child = spawn(
            `${process.env.HOME}/claude-sandbox.sh`,
            ["--spawn", session.dir, "--resume", windowName],
            { timeout: 600000, shell: false }
          );
          let stdout = "", stderr = "";
          child.stdout.on("data", d => stdout += d);
          child.stderr.on("data", d => stderr += d);
          child.on("close", code => {
            if (code !== 0) reject(new Error(stderr || `Exit code ${code}`));
            else resolve(stdout);
          });
          child.on("error", reject);
        });
        results.push(`${windowName}: restored`);
        spawned++;
      } catch (e) {
        removeSession(REGISTRY_PATH, windowName);
        results.push(`${windowName}: failed (${e.message})`);
      }
    }

    return { content: [{ type: "text", text: results.join("\n") }] };
  }
};

function validateAuth(req, res, next) {
  const auth = req.headers.authorization;
  if (auth === `Bearer ${BEARER_TOKEN}`) {
    req.role = "control-plane";
  } else if (auth === `Bearer ${SESSION_TOKEN}`) {
    req.role = "session";
  } else {
    return res.status(401).json({ error: "Unauthorized" });
  }
  next();
}

async function handleJsonRpc(request, role) {
  const { method, params, id } = request;
  const isSession = role === "session";

  switch (method) {
    case "initialize":
      return {
        jsonrpc: "2.0", id,
        result: {
          protocolVersion: "2024-11-05",
          capabilities: { tools: {} },
          serverInfo: { name: "tmux-control-plane", version: "1.0.0" }
        }
      };
    case "notifications/initialized":
      return null;
    case "tools/list": {
      const tools = isSession ? TOOLS.filter(t => SESSION_TOOLS.has(t.name)) : TOOLS;
      return { jsonrpc: "2.0", id, result: { tools } };
    }
    case "tools/call": {
      const { name, arguments: args } = params;
      if (isSession && !SESSION_TOOLS.has(name)) {
        return { jsonrpc: "2.0", id, error: { code: -32601, message: `Unknown tool: ${name}` } };
      }
      const handler = toolHandlers[name];
      if (!handler) {
        return { jsonrpc: "2.0", id, error: { code: -32601, message: `Unknown tool: ${name}` } };
      }
      const result = await handler(args || {});
      return { jsonrpc: "2.0", id, result };
    }
    default:
      return { jsonrpc: "2.0", id, error: { code: -32601, message: `Method not found: ${method}` } };
  }
}

app.post("/mcp", validateAuth, async (req, res) => {
  try {
    const response = await handleJsonRpc(req.body, req.role);
    if (response === null) return res.status(202).end();
    res.json(response);
  } catch (e) {
    res.status(500).json({ jsonrpc: "2.0", id: req.body?.id, error: { code: -32603, message: e.message } });
  }
});

app.get("/health", (req, res) => res.json({ status: "ok" }));

app.listen(PORT, "0.0.0.0", () => {
  console.log(`tmux-control-plane running on http://0.0.0.0:${PORT}/mcp`);

  // Auto-restore sessions after boot (delay lets tmux session initialize)
  setTimeout(async () => {
    console.log("Checking for sessions to restore...");
    try {
      const result = await toolHandlers.restore_sessions({});
      console.log("Restore result:", result.content[0].text);
    } catch (e) {
      console.error("Restore failed:", e.message);
    }
  }, RESTORE_DELAY * 1000);
});
