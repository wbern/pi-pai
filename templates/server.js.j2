import express from "express";
import { execFileSync, spawn } from "child_process";

const app = express();
const PORT = {{ mcp_server_port }};
const BEARER_TOKEN = "{{ mcp_bearer_token }}";

app.use(express.json());

// Safe shell execution using execFileSync (no shell interpolation)
function run(cmd, args = []) {
  try {
    return execFileSync(cmd, args, { encoding: "utf8", timeout: 30000 }).trim();
  } catch (e) {
    throw new Error(e.stderr || e.message);
  }
}

// Validate input: alphanumeric, dash, underscore, dot, slash only
function sanitize(str, allowSlash = false) {
  if (!str) return "";
  const pattern = allowSlash ? /[^a-zA-Z0-9\-_./@ ]/g : /[^a-zA-Z0-9\-_. ]/g;
  return str.replace(pattern, "");
}

const TOOLS = [
  {
    name: "list_sessions",
    description: "List all active tmux windows in the Claude session",
    inputSchema: { type: "object", properties: {}, required: [] }
  },
  {
    name: "spawn_session",
    description: "Spawn a new Claude project session. Can clone repos, run tasks, or start blank sessions.",
    inputSchema: {
      type: "object",
      properties: {
        repo: { type: "string", description: "Git URL to clone (e.g., github.com/user/repo)" },
        instruction: { type: "string", description: "Task or instructions for Claude" },
        window_name: { type: "string", description: "Custom window name (auto-generated if not provided)" }
      },
      required: []
    }
  },
  {
    name: "kill_session",
    description: "Kill a tmux window by name or index",
    inputSchema: {
      type: "object",
      properties: {
        target: { type: "string", description: "Window name or index to kill" }
      },
      required: ["target"]
    }
  },
  {
    name: "end_session",
    description: "End a Claude session by window name. Use list_sessions first to find window names.",
    inputSchema: {
      type: "object",
      properties: {
        window: { type: "string", description: "Window name from list_sessions" }
      },
      required: ["window"]
    }
  }
];

const toolHandlers = {
  list_sessions: async () => {
    try {
      const output = run("tmux", ["list-windows", "-t", "{{ tmux_session_name }}", "-F", "#{window_index}: #{window_name}"]);
      return { content: [{ type: "text", text: output || "No windows found" }] };
    } catch (e) {
      return { content: [{ type: "text", text: `Error: ${e.message}` }], isError: true };
    }
  },

  spawn_session: async ({ repo, instruction, window_name }) => {
    // Sanitize inputs to prevent injection
    const safeRepo = sanitize(repo, true);  // allow slashes for URLs
    const safeInstruction = instruction ? instruction.substring(0, 500) : "";  // limit length

    // Build prompt based on inputs
    let prompt = "";
    if (safeRepo && safeInstruction) {
      prompt = `Clone ${safeRepo}, then ${safeInstruction}`;
    } else if (safeRepo) {
      prompt = `Clone ${safeRepo} and explore the codebase`;
    } else if (safeInstruction) {
      prompt = safeInstruction;
    }

    // Determine window name (sanitized)
    let windowName = sanitize(window_name);
    if (!windowName) {
      if (safeRepo) {
        windowName = sanitize(safeRepo.split("/").pop().replace(".git", ""));
      } else {
        windowName = `session-${Date.now()}`;
      }
    }

    try {
      // Use spawn with array arguments (no shell interpolation)
      const result = await new Promise((resolve, reject) => {
        const child = spawn(
          `${process.env.HOME}/claude-sandbox.sh`,
          ["--spawn", prompt, windowName],
          { timeout: 600000, shell: false }
        );
        let stdout = "", stderr = "";
        child.stdout.on("data", d => stdout += d);
        child.stderr.on("data", d => stderr += d);
        child.on("close", code => {
          if (code !== 0) reject(new Error(stderr || `Exit code ${code}`));
          else resolve(stdout);
        });
        child.on("error", reject);
      });
      console.log("Spawned:", result);
      return { content: [{ type: "text", text: `Spawned "${windowName}". Use list_sessions to see all windows.` }] };
    } catch (e) {
      console.error("Spawn error:", e.message);
      return { content: [{ type: "text", text: `Failed to spawn "${windowName}": ${e.message}` }], isError: true };
    }
  },

  kill_session: async ({ target }) => {
    const safeTarget = sanitize(target);
    if (!safeTarget) {
      return { content: [{ type: "text", text: "Error: Invalid target" }], isError: true };
    }
    try {
      run("tmux", ["kill-window", "-t", `{{ tmux_session_name }}:${safeTarget}`]);
      return { content: [{ type: "text", text: `Killed window: ${safeTarget}` }] };
    } catch (e) {
      return { content: [{ type: "text", text: `Error: ${e.message}` }], isError: true };
    }
  },

  // Alias for kill_session (same functionality, different API)
  end_session: async ({ window }) => {
    return toolHandlers.kill_session({ target: window });
  }
};

function validateAuth(req, res, next) {
  const auth = req.headers.authorization;
  if (!auth || auth !== `Bearer ${BEARER_TOKEN}`) {
    return res.status(401).json({ error: "Unauthorized" });
  }
  next();
}

async function handleJsonRpc(request) {
  const { method, params, id } = request;

  switch (method) {
    case "initialize":
      return {
        jsonrpc: "2.0", id,
        result: {
          protocolVersion: "2024-11-05",
          capabilities: { tools: {} },
          serverInfo: { name: "tmux-control-plane", version: "1.0.0" }
        }
      };
    case "notifications/initialized":
      return null;
    case "tools/list":
      return { jsonrpc: "2.0", id, result: { tools: TOOLS } };
    case "tools/call":
      const { name, arguments: args } = params;
      const handler = toolHandlers[name];
      if (!handler) {
        return { jsonrpc: "2.0", id, error: { code: -32601, message: `Unknown tool: ${name}` } };
      }
      const result = await handler(args || {});
      return { jsonrpc: "2.0", id, result };
    default:
      return { jsonrpc: "2.0", id, error: { code: -32601, message: `Method not found: ${method}` } };
  }
}

app.post("/mcp", validateAuth, async (req, res) => {
  try {
    const response = await handleJsonRpc(req.body);
    if (response === null) return res.status(202).end();
    res.json(response);
  } catch (e) {
    res.status(500).json({ jsonrpc: "2.0", id: req.body?.id, error: { code: -32603, message: e.message } });
  }
});

app.get("/health", (req, res) => res.json({ status: "ok" }));

app.listen(PORT, "0.0.0.0", () => {
  console.log(`tmux-control-plane running on http://0.0.0.0:${PORT}/mcp`);
});
